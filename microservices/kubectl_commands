#creates deployment
kubectl create deployment <deployment_name> --image=<image>

#creates a service/network to expose pods
kubectl expose deployment <deployment_name> --port=8000 --type=LoadBalancer

#increase to the number of containers to 3
kubectl scale deployment/<deployment_name> --replicas=3

#reduce the number of containers to 1
kubectl scale deployment/<deployment_name> --replicas=1

#refresh the image used by the deployment, to trigger the refresh
#it is necessary that the tag of the image has changed otherwise
#kubernetes won't update it, even if the image content has been
#changed, the name:tag of the image is the only thing that
#kubernetes will check to know if a container should replace its
#image
kubectl set image deployment/<deployment_name> <container_name>=<image>

#inspect a deployment update
kubectl rollout status deployment/<deployment_name>

#rollback a failed deployment update
kubectl rollout undo deployment/<deployment_name>

#shows the revisions/updates of the deployment
kubectl rollout history deployment/<deployment_name>

#show details of a specific revision
kubectl rollout history deployment/<deployment_name> --revision=4

#change the state of the deployment to a specific revision
kubectl rollout undo deployment/<deployment_name> --to-revision=1

#list deployments
kubectl get deployments

#list pods
kubectl get pods

#list services
kubectl get services

#apply a deployment.yaml file
kubectl apply -f=deployment.yaml

#deletes a deployment
kubectl delete deployment <service_name>

#deletes a service
kubectl delete service <service_name>

#delete resources declared in yaml files
kubectl delete -f=deployment.yaml,service.yaml
kubectl delete -f=deployment.yaml -f=service.yaml

#delete resources based on the labels
kubectl delete deployments,services -l group=example